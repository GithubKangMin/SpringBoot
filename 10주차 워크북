<aside>
<img src="/icons/list_gray.svg" alt="/icons/list_gray.svg" width="40px" /> **목차**

</aside>

## 📝 학습 목표

1. 스프링 시큐리티를 활용한 간단한 로그인 및 회원가입 기능 구현해보기
2. 카카오톡 소셜 로그인 구현해보기

## 📸 잠깐! 스터디 인증샷은 찍으셨나요?

<aside>
💡 스터디장께서는 대표로 매 주차 스터디 인증샷을 남겨주세요!
사진을 저장하여 이미지 업로드할 수도 있고, 복사 & 붙여넣기를 통해 업로드할 수도 있습니다.

</aside>

[]()

## 📑 10주차 주제: 스프링 부트를 이용한 로그인 및 회원가입 구현

## 🔖 10주차 본문

이번 주차를 통해 스프링 부트를 이용한 로그인 및 회원가입을 직접 구현해 볼 예정입니다.

해당 주차의 경우 개념이 다소 복잡하기 때문에 간단한 개념 설명과 실습 위주로 구성되어 있습니다.

## 0. 들어가기 전

이번 실습에서는 로그인 및 회원가입 기능을 구현하기 위해, 기본적인 보안 설정을 먼저 구성해야 합니다. 이를 위해 **Spring Security**를 활용하며, 기본적인 설정을 추가하여 웹 보안 기능이 어떻게 자동으로 적용되는지 확인해볼 것입니다.

로그인 및 회원가입 기능을 구현하기 전에, 프로젝트에 필요한 보안 설정을 구성하기 위해 먼저 의존성을 추가해보겠습니다.

```groovy
dependencies {
		implementation 'org.springframework.boot:spring-boot-starter-security'
		testImplementation 'org.springframework.security:spring-security-test'
}
```

이 의존성들을 추가하면, Spring Security는 기본적으로 **자동 설정(Auto-Configuration)**을 통해 프로젝트에 기본적인 보안 기능을 적용합니다. 즉, 별도의 설정이나 코드 작성 없이도 시스템에 기본적인 보안이 활성화됩니다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/21fe06fb-a28a-45e0-bf1d-71a0d2d68a2b/image.png)

또한, 애플리케이션 실행 로그에서 기본 계정의 **패스워드**가 자동으로 생성된 것을 확인할 수 있습니다. 이 패스워드를 사용하여 제공된 기본 계정으로 로그인할 수 있습니다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/3db6d964-c76f-461a-b61f-3cd366606e1a/image.png)

이 상태에서 프로젝트에는 기본적으로 한 개의 계정만 제공되며, 이 계정으로 로그인할 수 있습니다.

하지만, 실제 애플리케이션에서는 **사용자 정의 계정**과 **권한 부여(Authorization)**, **추가적인 보안 기능**이 필요합니다. 기본적으로 제공되는 보안 설정을 프로젝트 요구 사항에 맞게 **커스터마이징**하는 것이 중요합니다.

즉, Spring Security 의존성을 추가하면 **기본 보안 설정 클래스**가 자동으로 생성되고, 우리는 이를 각자의 프로젝트에 맞게 변경하여 보안을 구성하게 되는 것입니다.

이제, 기본적인 보안 설정을 직접 변경하고, 로그인 및 회원가입 기능을 구현하는 과정을 시작해봅시다.

그 전에 간단하게 스프링 시큐리티에 대해서 주요 개념들을 짚어보고 넘어가겠습니다.

---

## 1. Spring Security 개요 및 주요 흐름

이제 웹 애플리케이션 개발에서 핵심적인 부분인 Spring Security에 대해 자세히 알아보겠습니다.

현대 웹 개발에서 보안은 선택이 아닌 필수입니다. 따라서 Spring Security를 제대로 이해하고 사용하면, 안전하고 견고한 애플리케이션을 쉽게 만들 수 있습니다.

### 1️⃣ Spring Security란?

Spring Security는 Spring 기반 애플리케이션의 보안을 담당하는 강력한 프레임워크입니다. 주로 두 가지 핵심 기능인 **인증**과 **권한 부여**를 제공합니다.

Spring Security는 주로 다음 역할들을 수행합니다.

1. 누가 들어오는지 확인합니다 (인증, Authentication)
2. 들어온 사람이 어디에 갈 수 있는지 결정합니다 (인가, Authorization)
3. 위험한 상황으로부터 보호합니다 (다양한 보안 위협 방어)

### 2️⃣ 핵심 개념

인증과 인가는 Spring Security의 가장 기본적인 개념입니다.

1. **인증(Authentication)**

    인증은 "당신이 누구인지 증명하세요"라고 묻는 과정입니다.

    사용자가 제공한 크리덴셜(보통 아이디와 비밀번호)을 확인하여 신원을 검증합니다.

    ```java
    public interface Authentication extends Principal, Serializable {
        Collection<? extends GrantedAuthority> getAuthorities();
        Object getCredentials();
        Object getDetails();
        Object getPrincipal();
        boolean isAuthenticated();
        void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException;
    }
    ```

    이 `Authentication` 인터페이스는 인증된 사용자의 정보를 담고 있습니다.

    `getPrincipal()`은 사용자의 식별 정보를, `getAuthorities()`는 사용자의 권한 정보를 반환합니다.

2. **인가(Authorization)**

    인가는 "이 리소스에 접근할 권한이 있나요?"를 확인하는 과정입니다.

    인증된 사용자가 특정 리소스에 접근할 수 있는지, 특정 동작을 수행할 수 있는지를 결정합니다.


간단하게 일상생활과 비유하면,

1. 프로미스나인 공연에 가려고 해요 (애플리케이션 접근)
2. 입구에서 티켓을 보여줍니다 (인증)
3. 가이드가 날짜와 인원 그리고 좌석을 확인하고 들어갈 수 있게 해줍니다 (인가)

와 같습니다.

그렇다면, 스프링 시큐리티에서 인증과 인가 흐름 어떻게 이루어질까요?

![Untitled diagram-2024-10-11-052018.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/0c1e708e-cfcc-4d32-9ff3-dc06fcdaa73a/Untitled_diagram-2024-10-11-052018.png)

위의 도식화처럼 인증과 인가의 절차가 진행됩니다!!! 물론 아직 모르는 클래스들이 많기 때문에 복잡해 보일 수 있지만, 하나하나씩 알아가보겠습니다.

<aside>
💡

**왜 Spring Security를 사용하는가?**

- **인증/인가 기능 제공**: 사용자 인증, 권한 관리, 세션 유지 등 복잡한 보안 문제를 간단하게 처리할 수 있습니다.
- **Spring 생태계에 통합**: Spring Framework와 자연스럽게 통합되어 있어, 개발 과정에서 보안 기능을 추가하는 데 용이합니다.
- **확장성**: 기본 보안 설정을 바탕으로 다양한 요구 사항에 맞게 확장할 수 있습니다.
</aside>

---

### 3️⃣ Spring Security 주요 컴포넌트

스프링 시큐리티는 여러 주요 컴포넌트가 협력하여 인증과 인가를 처리합니다.

이제 각 컴포넌트의 역할을 살펴보겠습니다.

1. **AuthenticationManager:**
    - **인증(Authentication)** 과정을 관리하는 중심 컴포넌트입니다.
    - 사용자가 로그인을 시도할 때, **`AuthenticationManager`**가 사용자의 자격 증명(예: 이메일/비밀번호)을 받아 이를 인증할 수 있는 프로세스를 호출합니다.

        ![[Spring security 공식 문서](https://docs.spring.io/spring-security/reference/servlet/authentication/architecture.html)](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/ca064b61-da69-455e-b448-6916e089093b/image.png)

        [Spring security 공식 문서](https://docs.spring.io/spring-security/reference/servlet/authentication/architecture.html)

2. **AuthenticationProvider:**
    - 실제로 인증 로직을 처리하는 역할을 담당합니다.
    - 여러 **`AuthenticationProvider`**가 존재할 수 있으며, 각각은 특정 인증 방식을 처리합니다.
        - 예를 들어, 기본적인 이메일/비밀번호 인증은 하나의 **`AuthenticationProvider`**에서 처리하고, 소셜 로그인의 경우 또 다른 **`AuthenticationProvider`**가 담당할 수 있습니다.

        ![[Spring security 공식 문서](https://docs.spring.io/spring-security/reference/servlet/authentication/architecture.html)](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/f944d8de-543f-41c0-8f2d-c7a3b0b31415/image.png)

        [Spring security 공식 문서](https://docs.spring.io/spring-security/reference/servlet/authentication/architecture.html)

3. **UserDetailsService**:
    - 사용자 정보를 불러오고 검증하는 서비스입니다.
    - 이 서비스는 데이터베이스 또는 다른 저장소에서 사용자 정보를 가져오고, 이를 **`UserDetails`** 객체로 반환합니다.
        - **`UserDetails`** 객체: 사용자의 아이디, 비밀번호, 권한(Role) 등 다양한 정보를 포함합니다.
4. **SecurityContext**:
    - **인증이 완료된 사용자 정보를 저장하는 컨텍스트**입니다.
    - 이 정보는 애플리케이션 전반에서 공유되며, **`SecurityContextHolder`**를 통해 접근할 수 있습니다.

        ![[Spring security 공식 문서](https://docs.spring.io/spring-security/reference/servlet/authentication/architecture.html)](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/f354a6c1-ec07-4e0b-9442-4d61dd9cdd34/image.png)

        [Spring security 공식 문서](https://docs.spring.io/spring-security/reference/servlet/authentication/architecture.html)


---

### 4️⃣ **SecurityContextHolder**

`SecurityContextHolder`는 현재 보안 컨텍스트에 대한 세부 정보를 보관합니다.

기본적으로 **ThreadLocal**을 사용하여 동일한 스레드 내에서는 각 사용자의 인증 정보를 개별적으로 유지합니다.

즉, 요청마다 인증된 사용자의 정보를 보존하고, 다른 요청에서는 다른 사용자의 정보를 처리할 수 있도록 합니다.

<aside>
💡

**SecurityContextHolder의 주요 역할**

1. 인증된 사용자 정보를 **SecurityContext**에 저장 및 관리.
2. 이후의 요청에서 **SecurityContext**를 통해 인증된 정보를 참조하여 사용자의 권한이나 인증 상태를 확인.
3. 애플리케이션의 어디서나 **`SecurityContextHolder.getContext()`** 메서드를 사용해 인증 정보를 접근할 수 있습니다.

    ```java
    Authentication authentication
    		= SecurityContextHolder.getContext().getAuthentication();

    String username = authentication.getName();  // 사용자 이름
    Object principal = authentication.getPrincipal();
    Collection<? extends GrantedAuthority> authorities
    		= authentication.getAuthorities();  // 권한 목록
    ```

</aside>

---

### 5️⃣ **Filter Chain**

Filter Chain은 Spring Security에서 HTTP 요청을 처리할 때 사용하는 일련의 필터들입니다. 각 필터는 특정 보안 기능을 담당하며, 요청이 애플리케이션에 도달하기 전에 이 필터들을 순차적으로 통과합니다.

**다음은 주요 필터들입니다.**

1. **SecurityContextPersistenceFilter**
    - 요청 간 SecurityContext를 유지합니다.
    - 새 요청이 들어올 때 이전에 인증된 사용자의 정보를 복원합니다.
2. **UsernamePasswordAuthenticationFilter**
    - 폼 기반 로그인을 처리합니다.
    - 사용자가 제출한 username과 password를 확인하여 인증을 시도합니다.
3. **AnonymousAuthenticationFilter**
    - 이전 필터에서 인증되지 않은 요청에 대해 익명 사용자 인증을 제공합니다.
4. **ExceptionTranslationFilter**
    - Spring Security 예외를 HTTP 응답으로 변환합니다.
    - 인증 실패 시 로그인 페이지로 리다이렉트하거나, 인가 실패 시 403 오류를 반환합니다.
5. **FilterSecurityInterceptor**
    - 접근 제어 결정을 내리는 마지막 필터입니다.
    - 현재 인증된 사용자가 요청한 리소스에 접근할 권한이 있는지 확인합니다.

그렇다면 이러한 Filter Chain의 동작 방식에 대해 알아보겠습니다.

1. 클라이언트로부터 요청이 들어오면, 요청은 Filter Chain의 첫 번째 필터부터 순차적으로 통과합니다.
2. 각 필터는 요청을 검사하고 필요한 작업을 수행합니다.
3. 필터는 요청을 다음 필터로 전달하거나, 특정 조건에 따라 요청 처리를 중단할 수 있습니다.
4. 모든 필터를 통과한 요청만이 실제 애플리케이션 로직에 도달합니다.

![Untitled diagram-2024-10-11-053833.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/e82cce99-4ceb-48e7-b039-332fd259a941/Untitled_diagram-2024-10-11-053833.png)

---

### 6️⃣ Spring Security의 인증과 인가 흐름

이제 앞서 설명한 주요 컴포넌트들이 어떻게 상호작용하여 **인증(Authentication)**과 **인가(Authorization)** 과정을 처리하는지 살펴보겠습니다.

**[인증(Authentication) 흐름]**

인증은 사용자의 신원을 확인하는 과정입니다. Spring Security에서의 인증 흐름은 다음과 같습니다:

1. **사용자 로그인 요청**:
    - 사용자가 로그인 폼에 credentials(예: 이메일, 비밀번호)을 입력하고 제출합니다.
2. **AuthenticationFilter**:
    - `UsernamePasswordAuthenticationFilter`가 요청을 가로채고 `Authentication` 객체를 생성합니다.
3. **AuthenticationManager**:
    - `AuthenticationManager`는 적절한 `AuthenticationProvider`를 선택하여 인증을 위임합니다.
4. **AuthenticationProvider**:
    - 선택된 `AuthenticationProvider`는 `UserDetailsService`를 사용하여 사용자 정보를 로드합니다.
    - 로드된 정보를 바탕으로 비밀번호를 검증합니다.
5. **UserDetailsService**:
    - 데이터베이스나 다른 저장소에서 사용자 정보를 조회합니다.
6. **SecurityContext**:
    - 인증이 성공하면, `Authentication` 객체가 `SecurityContext`에 저장됩니다.

---

**[인가(Authorization) 흐름]**

인가는 인증된 사용자가 특정 리소스에 접근할 권한이 있는지 확인하는 과정입니다:

1. **리소스 접근 요청**:
    - 인증된 사용자가 보호된 리소스에 접근을 시도합니다.
2. **FilterSecurityInterceptor**:
    - `FilterSecurityInterceptor`가 요청을 가로채고 권한 검사를 시작합니다.
3. **AccessDecisionManager**:
    - `AccessDecisionManager`는 현재 사용자의 권한과 요청된 리소스의 필요 권한을 비교합니다.
4. **권한 확인**:
    - `SecurityContext`에서 현재 인증된 사용자의 권한 정보를 조회합니다.
5. **접근 결정**:
    - 사용자의 권한이 충분하면 리소스 접근이 허용됩니다.
    - 권한이 부족하면 `AccessDeniedException`이 발생하고 접근이 거부됩니다.

즉 앞서 보여드린 다음과 같은 형태로 인증가 인가가 처리됩니다.

![Untitled diagram-2024-10-11-052018.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/0c1e708e-cfcc-4d32-9ff3-dc06fcdaa73a/Untitled_diagram-2024-10-11-052018.png)

지금까지 Spring Security의 기본 개념과 주요 컴포넌트들에 대해 간단히 알아보았습니다.

하지만 이는 Spring Security가 제공하는 방대한 기능과 개념 중 극히 일부에 불과합니다.

아직 모르는 더 많은 고급 기능과 보안 기법들이 존재합니다.

이제 실습을 통해 지금까지 배운 내용을 적용해볼 것입니다. 기본적인 인증과 인가 구현에는 문제가 없습니다.

만약 여러분의 프로젝트에 더 맞춤화된, 더 강력한 보안을 적용하고 싶다면, 아래 제시된 학습 주제들을 공부해보시기 바랍니다.

1. **Spring Security 기본 구성**
    - SecurityFilterChain 구성
    - WebSecurityConfigurerAdapter (deprecated) vs SecurityFilterChain
    - HTTP Basic 인증과 Form 기반 인증
2. **사용자 관리**
    - UserDetailsService 구현
    - PasswordEncoder 사용법
    - 사용자 정보 저장소 (인메모리, JDBC, JPA)
3. **인증 심화**
    - JWT (JSON Web Token) 인증
    - OAuth2 및 소셜 로그인
    - Remember-Me 인증
4. **권한 부여 (Authorization)**
    - 메소드 보안 (@PreAuthorize, @PostAuthorize)
    - SpEL (Spring Expression Language)을 이용한 동적 권한 부여
    - ACL (Access Control List)
5. **CSRF, XSS 방어**
    - CSRF 토큰 사용법
    - XSS 방지를 위한 출력 이스케이핑
6. **세션 관리**
    - 세션 고정 공격 방어
    - 동시 세션 제어
7. **테스트**
    - Spring Security Test 모듈 사용법
    - MockMvc를 이용한 보안 테스트
8. **Spring Security 아키텍처 심화**
    - SecurityContextHolder 전략
    - AuthenticationProvider 커스터마이징
    - Filter 추가 및 커스터마이징

<aside>
💡

**추가 학습 자료:**

- https://github.com/spring-projects/spring-security/milestones
- https://docs.spring.io/spring-security/reference/index.html
- https://www.baeldung.com/security-spring
</aside>

Spring Security는 깊이 있게 파고들수록 더 많은 것을 배울 수 있는 넓고 깊은 주제입니다. 지금은 기본을 익히는 데 집중하고, 앞으로 프로젝트의 요구사항에 따라 조금씩 더 고급 기능들을 학습하고 적용해 나가시기 바랍니다.

이제 실습으로 넘어가 Spring Security를 실제 코드에 적용해보면서, 이론으로 배운 내용들이 어떻게 동작하는지 직접 확인해봅시다. 화이팅!

---

# 실습 1: 간단한 로그인 및 회원가입 구현

이번 실습에서는 **Spring Security**를 사용해 간단한 로그인과 회원가입 기능을 구현합니다.

지금까지 여러분은 9주차 동안 다양한 API를 구현해 왔습니다.

하지만, 만약 누구나 여러분의 API에 접근할 수 있다면 어떤 일이 벌어질까요?

이를 해결하기 위해 우리는 **Spring Security**로 보안을 설정해 보려고 합니다. 이 과정을 통해 인증과 권한 관리가 어떻게 이루어지는지 기본적인 개념을 익힐 수 있습니다.

물론, 이번 실습에서는 **기본적인 보안 기능**만 다룹니다. 실제 프로젝트에서는 더 많은 보안 기능을 추가하고, 사용자 관리를 더욱 철저하게 해야 합니다!!

---

## 0. 들어가기 전

이번 실습은 **9주차까지 진행한 프로젝트**를 그대로 이어서 진행합니다.

그리고 **Thymeleaf**라는 템플릿 엔진을 이용해 결과를 화면에 출력할 예정입니다.

타임 리프…? 이게 무엇일까요?

> **Thymeleaf**는 Spring Boot에서 HTML을 렌더링하기 위한 템플릿 엔진으로, 백엔드 개발자가 뷰(View)를 구성하는 데 유용한 도구입니다.
>

이번 실습에서 **Thymeleaf**는 결과 확인을 위한 용도로만 사용되며, 별도의 추가 학습이 필요하지 않습니다.

그렇다면 실제 협업 시에는 어떻게 할까요?

실제 프로젝트를 진행하거나 협업할 때는 프론트엔드 개발자와 **REST API**를 통해 데이터를 주고받는 방식으로 구현하게 됩니다.

하지만, 백엔드 로직에 집중하기 위해 이번 실습에서는 **Thymeleaf로 간단한 HTML 페이지**를 만들고 결과를 확인하는 방식으로 진행할 예정입니다.

### 1️⃣ Thymeleaf 의존성 추가하기

**Thymeleaf**를 사용하기 위해 필요한 의존성을 추가해야 합니다. `build.gradle` 파일에 다음 내용을 추가해주세요

```groovy
implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'
```

### 2️⃣  HTML 파일 추가하기

실습에 필요한 HTML 파일을 프로젝트에 추가해야 합니다. 아래 [**커밋 링크**](https://www.notion.so/Chapter-10-1-fa825ed5a97045debf32e1b2e494021a?pvs=21)를 참고하여, `src/main/resources/templates` 폴더에 **네 가지 HTML 파일**을 생성해 주세요.

만약 `templates` 폴더가 없다면 생성한 후, 폴더 안에 네 가지 파일을 만들어 주시면 됩니다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/5e72db92-c806-477e-9423-e0983f04f50d/image.png)

커밋 링크: https://github.com/chock-cho/UMC-7th-spring-workbook/commit/04cf9dcc470e6bb3fb9a95abbf1666b75b1eecd6

### 3️⃣ View Controller 추가

이제 Thymeleaf로 만든 HTML 페이지들을 렌더링하기 위한 Controller를 추가하겠습니다. 이 Controller는 Spring Security를 적용하기 전에 기본적인 페이지 네비게이션을 설정하는 데 도움이 됩니다.

`src/main/java/web/controller` 패키지에 `MemberViewController` 클래스를 생성하고 다음과 같이 작성해주세요

```java
@Controller
public class MemberViewController {

    @GetMapping("/login")
    public String loginPage() {
        return "login";
    }

    @GetMapping("/signup")
    public String signupPage(Model model) {
        model.addAttribute("memberJoinDto", new MemberRequestDTO.JoinDto());
        return "signup";
    }

    @GetMapping("/home")
    public String home() {
        return "home";
    }

    @GetMapping("/admin")
    public String admin() {
        return "admin";
    }
}
```

이 Controller는 다음과 같은 역할을 합니다:

1. `/login` 경로로 접속하면 `login.html`을 보여줍니다.
2. `/signup` 경로로 접속하면 `signup.html`을 보여주며, 회원가입 폼에 필요한 빈 DTO 객체를 모델에 추가합니다.
3. `/home` 경로로 접속하면 `home.html`을 보여줍니다.
4. `/admin` 경로로 접속하면 `admin.html`을 보여줍니다.

이렇게 Controller를 추가함으로써, Thymeleaf 템플릿과 Spring MVC를 연결하고 기본적인 페이지 네비게이션을 설정할 수 있습니다.

---

## 1. Spring Security 설정 및 구현

이제 본격적으로 Spring Security를 설정하고 구현해볼 텐데요.

> **Spring Security는 로그인, 회원가입, 로그아웃 같은 기본적인 보안 기능부터 복잡한 인증 프로세스까지 쉽게 구현할 수 있게 해주는 강력한 도구입니다.**
>

만약 여러분이 직접 이런 기능들을 구현하려면 얼마나 많은 시간이 걸릴까요…?

아마 직접 구현한다면, 방학동안 프로젝트를 데모데이 전까지 수행하기 힘들거라고 생각됩니다.

따라서 Spring Security를 사용하여 이런 복잡한 작업들을 훨씬 쉽게 처리해서 데모데이 전까지, 성공적으로 서버를 완벽하게 구축하셨으면 좋겠습니다!!!

### 1️⃣ Security 의존성 추가하기

먼저, Spring Security를 사용하기 위해 필요한 의존성을 추가해야 합니다. `build.gradle` 파일에 다음 내용을 추가해주세요!

```groovy
implementation 'org.springframework.boot:spring-boot-starter-security'
testImplementation 'org.springframework.security:spring-security-test'
```

이 의존성들을 통해 Spring Security의 핵심 기능과 테스트 도구를 사용할 수 있습니다.

추가적으로 thymeleaf에서도 security가 동작하게 하기 위해서 다음 의존성도 추가합니다.

```groovy
implementation 'org.thymeleaf.extras:thymeleaf-extras-springsecurity6:3.1.1.RELEASE'
```

### **2️⃣ Security 설정하기**

Spring Security는 매우 유연한 보안 프레임워크입니다. 가장 기본적인 설정으로도 로그인, 로그아웃 같은 기능을 쉽게 구현할 수 있지만, 실제로는 **더 많은 보안 요구사항**을 처리할 수 있습니다.

Spring Security를 설정하기 위해서 `SecurityConfig` 클래스를 만들어줘야 합니다!!!

`SecurityConfig` 클래스는 우리 애플리케이션의 보안 정책을 정의하는 곳입니다.

쉽게 말해,

> "이 URL은 누구나 접근 가능하고, 저 URL은 관리자만 접근 가능해"
>

라고 지정하는 곳입니다.

보안 설정을 위해 **Spring Security**는 **Filter Chain**을 사용하여 들어오는 HTTP 요청을 필터링하고, 인증 또는 인가 로직을 처리합니다. `SecurityConfig`는 그 필터 체인과 보안 정책을 설정하는 역할을 합니다.

우선, 아래와 같이 `src/main/java/umc/study/config` 위치에 `security` 폴더를 생성한 후, 폴더 내에 `SecurityConfig` 클래스를 생성해주세요.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/3b260bd5-a1d3-4d04-b566-a2d7b9e53f54/image.png)

그리고 아래 코드를 추가하면 됩니다!!!

```java
@EnableWebSecurity
@Configuration
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests((requests) -> requests
                .requestMatchers("/", "/home", "/signup", "/css/**").permitAll()
                .requestMatchers("/admin/**").hasRole("ADMIN")
                .anyRequest().authenticated()
            )
            .formLogin((form) -> form
                .loginPage("/login")
                .defaultSuccessUrl("/home", true)
                .permitAll()
            )
            .logout((logout) -> logout
                .logoutUrl("/logout")
                .logoutSuccessUrl("/login?logout")
                .permitAll()
            );

        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

자, 이제 `SecurityConfig` 클래스의 코드를 하나씩 뜯어보며 확인해봅시다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/b78bb73f-35c0-45ac-a77f-4447f107f7bd/image.png)

`SecurityConfig` ****클래스에 붙은 **`@**EnableWebSecurity` ****어노테이션은 Spring Security 설정을 활성화시키는 역할을 합니다.

따라서 우리가 직접 작성한 보안 설정이 Spring Security의 기본 설정보다 우선 적용되게 됩니다!!!

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/d58775aa-f0c4-4377-8036-67820d8489a0/image.png)

이 메소드는 `SecurityFilterChain`을 정의합니다. `HttpSecurity` 객체를 통해 다양한 보안 설정을 구성할 수 있습니다.

- `authorizeHttpRequests()` 는 HTTP 요청에 대한 접근 제어를 설정합니다.
    - `.requestMatchers()` 메소드를 사용하여 특정 URL 패턴에 대한 접근 권한을 설정합니다.
    - `permitAll()`은 인증 없이 접근 가능한 경로를 지정합니다.
    - `hasRole("ADMIN")`은 'ADMIN' 역할을 가진 사용자만 접근 가능하도록 제한합니다.
    - `anyRequest().authenticated()`는 그 외 모든 요청에 대해 인증을 요구합니다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/b30b7d5c-0082-493f-a696-606e30278cfa/image.png)

이 부분은 폼 기반 로그인에 대한 설정입니다.

- 커스텀 로그인 페이지를 `/login` 경로로 지정합니다.
- 로그인 성공 시 `/home`으로 리다이렉트합니다.
- 로그인 페이지는 모든 사용자가 접근 가능하도록 설정합니다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/8e49b99d-a143-4453-972f-909bb38e5687/image.png)

로그아웃 처리에 대한 설정입니다.

- `/logout` 경로로 로그아웃을 처리합니다.
- 로그아웃 성공 시 `/login?logout`으로 리다이렉트합니다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/4c937663-6ed2-49ac-bf61-c8487a07f684/image.png)

비밀번호를 암호화하여 저장하기 위해 **BCryptPasswordEncoder**를 사용합니다.

위에서 사용한 코드들은 **기본적인 설정**에 해당하지만, 실제로는 다음과 같은 더 많은 기능을 사용할 수 있습니다.

---

### 3️⃣ **회원가입에 보안 추가하기**

지난 8주차에 구현한 회원가입 기능에 Spring Security를 적용하여 보안을 강화해보겠습니다.

먼저, 사용자 역할을 정의하는 **`Role`** 열거형을 추가합니다

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/5bd60353-533c-4518-8539-2fdd00fc75ba/image.png)

```java
public enum Role {
    ADMIN, USER
}
```

현재는 관리자와 일반 사용자 역할만 정의했지만, 필요에 따라 추가 역할을 정의할 수 있습니다.

다음으로 `Member` 엔티티에 보안 관련 필드 및 비밀번호 설정 함수를 추가합니다.

```java
@Entity
public class Member extends BaseEntity {
    // 기존 필드들...

    @Column(nullable = false, unique = true)
    private String email;

    @Column(nullable = false)
    private String password;

    @Enumerated(EnumType.STRING)
    private Role role;

    // 기존 필드들...

    public void encodePassword(String password) {
        this.password = password;
    }
}
```

추가된 필드에 따라 다음 클래스들을 하나하나 씩 수정합니다.

1.  **MemberRequestDTO** 수정

    `MemberRequestDTO.JoinDto`를 다음과 같이 수정하여 새로운 필드들을 포함시킵니다.

    ```java
    public class MemberRequestDTO {
        @Getter
        @Setter   // thymeleaf에서 사용하기 위해 추가
        public static class JoinDto {
            @NotBlank
            String name;
            @NotBlank
            @Email
            String email;    // 이메일 필드 추가
            @NotBlank
            String password;    // 비밀번호 필드 추가
            @NotNull
            Integer gender;
            @NotNull
            Integer birthYear;
            @NotNull
            Integer birthMonth;
            @NotNull
            Integer birthDay;
            @Size(min = 5, max = 12)
            String address;
            @Size(min = 5, max = 12)
            String specAddress;
            List<Long> preferCategory;
            @NotNull
            Role role;    // 역할 필드 추가
        }
    }
    ```

2. **MemberConverter** 수정

    `MemberConverter` 클래스를 수정하여 새로운 필드들을 처리합니다.

    ```java
    public class MemberConverter {
        public static Member toMember(MemberRequestDTO.JoinDto request) {
            Gender gender = null;
            switch (request.getGender()) {
                case 1: gender = Gender.MALE; break;
                case 2: gender = Gender.FEMALE; break;
                case 3: gender = Gender.NONE; break;
            }

            return Member.builder()
                    .name(request.getName())
                    .email(request.getEmail())   // 추가된 코드
                    .password(request.getPassword())   // 추가된 코드
                    .gender(gender)
                    .address(request.getAddress())
                    .specAddress(request.getSpecAddress())
                    .role(request.getRole())   // 추가된 코드
                    .memberPreferList(new ArrayList<>())
                    .build();
        }
        // ... 기타 메소드들 ...
    }
    ```

3. **MemberViewController** 수정

    회원가입 폼 데이터를 처리하고, 회원가입 API를 정의합니다. 회원가입 요청이 들어오면 `MemberCommandService`를 사용하여 회원가입 로직을 수행하며, 그 과정에서 발생할 수 있는 예외 처리를 담당합니다.

    ```java
    @Controller
    @RequiredArgsConstructor
    public class MemberViewController {

        private final MemberCommandService memberCommandService;

        // thymeleaf 사용을 위해 일부가 변경되었습니다.
        // 실제로는 8주차에서 작성한 컨트롤러와 동일하게 작성하시면 됩니다!!
        @PostMapping("/members/signup")
        public String joinMember(@ModelAttribute("memberJoinDto") MemberRequestDTO.JoinDto request, // 협업시에는 기존 RequestBody 어노테이션을 붙여주시면 됩니다!
                                 BindingResult bindingResult,
                                 Model model) {
            if (bindingResult.hasErrors()) {
                // 뷰에 데이터 바인딩이 실패할 경우 signup 페이지를 유지합니다.
                return "signup";
            }

            try {
                memberCommandService.joinMember(request);
                return "redirect:/login";
            } catch (Exception e) {
                // 회원가입 과정에서 에러가 발생할 경우 에러 메시지를 보내고, signup 페이디를 유지합니다.
                model.addAttribute("error", e.getMessage());
                return "signup";
            }
        }

        // ... 기존 메소드들 ...
    }
    ```

4. **MemberCommandServiceImpl** 수정

    회원가입 로직에서 비밀번호를 암호화하여 저장하기 위해 `PasswordEncoder`를 사용합니다.

    ```java
    @Service
    @RequiredArgsConstructor
    public class MemberCommandServiceImpl implements MemberCommandService{

    		// ... 기존 코드 ...
        private final PasswordEncoder passwordEncoder;

        @Override
        @Transactional
        public Member joinMember(MemberRequestDTO.JoinDto request) {

            Member newMember = MemberConverter.toMember(request);

            newMember.encodePassword(passwordEncoder.encode(request.getPassword()));

    				// ... 기존 코드 ...
        }
    }
    ```

    <aside>

    **<`PasswordEncoder`를 사용한 비밀번호 암호화 사용 이유>**

    1. 보안 강화: 평문 비밀번호를 데이터베이스에 저장하지 않아 보안을 강화합니다.
    2. 단방향 해시: `BCryptPasswordEncoder`는 단방향 해시 함수를 사용하여 원본 비밀번호를 복원할 수 없게 만듭니다.
    3. 솔트(Salt) 사용: BCrypt는 자동으로 솔트를 생성하여 레인보우 테이블 공격을 방지합니다.
    </aside>

5. **SecurityConfig** 수정

    `SecurityConfig` 클래스에서 `/members/signup` 경로를 허용하도록 설정을 추가합니다.

    이를 통해 로그인을 하지 않아도, 새로 생성한 회원가입 API를 호출할 수 있습니다

    ```java
    @Configuration
    @EnableWebSecurity
    public class SecurityConfig {

        @Bean
        public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
            http
                .authorizeHttpRequests((requests) -> requests
                    .requestMatchers("/", "/home", "/signup", "/members/signup", "/css/**").permitAll()
                    .requestMatchers("/admin/**").hasRole("ADMIN")
                    .anyRequest().authenticated()
                )
                // ... 다른 설정들 ...

            return http.build();
        }

        // ... 다른 빈들 ...
    }
    ```


---

### 4️⃣ **회원가입 테스트**

이제 지금까지 만든 회원가입이 제대로 동작하는지 테스트해보겠습니다. 프로젝트를 빌드한 후, [회원가입 URL](http://localhost:8080/signup)에 접속하면 다음과 같은 페이지가 나타납니다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/fd82f2f8-ab2f-4227-b10c-db6f629d9298/image.png)

여기서 잠깐 회원가입 테스트 전에 DB에 음식 카테고리 데이터를 넣어줘야합니다!!!
회원가입 뷰에 한식, 중식, 일식만 추가하였기 때문에 이 세 가지 값을 DB에 직접 추가해줍니다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/c7f4e885-84d6-4636-b2bd-44ed905cd9db/image.png)

이제 회원가입 화면에서 데이터를 입력한 후, 역할은 일반 사용자를 선택하고 가입하기 버튼을 클릭하게 되면

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/5deceb59-cd59-450c-bebc-f93d70c3af08/image.png)

이렇게 로그인 화면으로 이동하게 됩니다. 그렇다면 과연 회원 정보가 잘 저장되었는지 확인해볼까요?

인텔리제이 로그를 통해 데이터베이스에 성공적으로 사용자가 저장되었음을 확인할 수 있습니다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/d30f418e-7c1f-4b5f-b019-983e505eced3/image.png)

또한 데이터베이스를 확인하면, 아래와 같이 member와 member_prefer 테이블에 정보가 잘 들어간 것을 볼 수 있습니다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/c0fd9ed3-37c7-44cc-800e-3b5484bbe62b/image.png)

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/154143bb-7a9c-45f3-b9da-63dadf0b1c74/image.png)

---

### 6️⃣ 로그인 구현

이제 회원가입이 정상적으로 동작하므로, **로그인 기능**을 구현해보겠습니다. Spring Security는 기본적으로 로그인 로직을 처리해주지만, 이를 위해 우리는 사용자 정보를 처리하는 `CustomUserDetailsService`를 만들어야 합니다.

특정 이메일을 사용하는 유저가 DB에 존재하는지 확인하기 위한 함수를 추가해줍니다.

`MemberRepository` 에 다음 함수를 추가합니다,

```java
public interface MemberRepository extends JpaRepository<Member, Long> {

    // ... 기존 함수 ...

    Optional<Member> findByEmail(String email);
}
```

**`src/main/java/umc/study/config/security`** 위치에 **`CustomUserDetailsService`** 클래스를 생성한 후, 아래의 코드를 작성해주시면 됩니다!!

```java
@Service
@RequiredArgsConstructor
public class CustomUserDetailsService implements UserDetailsService {

    private final MemberRepository memberRepository;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        Member member = memberRepository.findByEmail(username)
            .orElseThrow(() -> new UsernameNotFoundException("해당 이메일을 가진 유저가 존재하지 않습니다: " + username));

        return org.springframework.security.core.userdetails.User
            .withUsername(member.getEmail())
            .password(member.getPassword())
            .roles(member.getRole().name())
            .build();
    }
}
```

**동작 과정:**

1. 사용자가 로그인 폼에서 이메일과 비밀번호를 입력하고 제출합니다.
2. Spring Security가 `CustomUserDetailsService`의 `loadUserByUsername` 메소드를 호출합니다.
3. 이 메소드는 입력받은 이메일(username)으로 데이터베이스에서 사용자를 조회합니다.
4. 사용자가 존재하면 Spring Security의 `User` 객체로 변환하여 반환합니다.
5. Spring Security는 반환된 `User` 객체의 정보를 사용하여 인증을 수행합니다.

    ![Untitled diagram-2024-10-10-184109.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/d7cb1ede-9326-4cdc-aeb2-050356ead802/Untitled_diagram-2024-10-10-184109.png)


> **🔐 보안 강화 팁 🔐**
실제 애플리케이션에서는 로그인 시도 횟수 제한, 2단계 인증 등의 추가적인 보안 기능을 구현하는 것이 좋습니다.
>

---

### 7️⃣ 로그인 테스트

이제 로그인을 테스트해보겠습니다. Spring Security는 기본적으로 로그인 로직을 처리해주기 때문에, 로그인 페이지를 호출하고 로그인을 시도하면 별도의 추가 로직 없이도 작동합니다.

브라우저에서 [로그인 페이지](http://localhost:8080/login)로 이동합니다. 아래와 같은 화면이 표시됩니다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/f43c6970-5644-4fdf-8d50-b5e6ae9538f9/image.png)

이전에 회원가입한 사용자 계정으로 로그인해보겠습니다. email과 password를 입력하고 **Login** 버튼을 누릅니다.

로그인이 성공하면, **/home** 페이지로 이동하게 됩니다. 아래는 로그인 성공 후 이동한 **홈 페이지**입니다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/6963ed82-dd79-47a6-bd92-dd15bcc13f21/image.png)

---

### 8️⃣ 관리자 페이지 테스트

이번 실습에서 **Member 엔티티**에 **Role** 필드가 추가된 것을 확인할 수 있는데, 이를 통해 **페이지 접근 권한을 제어**할 수 있습니다. **Role** 필드는 사용자가 어떤 권한을 가지고 있는지 나타내며, **권한(Role)에 따라** 접근 가능한 페이지를 제어하게 됩니다.

**1. 일반 사용자로 관리자 페이지 접근 시**

현재 로그인 중인 계정이 **USER 권한**을 가진 상태에서 [**관리자 페이지**](http://localhost:8080/admin)에 접속하려고 하면, **403 Forbidden** 오류가 발생하게 됩니다.

![스크린샷 2024-09-05 오후 10.39.06.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/e45de9dc-ec67-421d-acf7-4335e3bae8a9/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-09-05_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.39.06.png)

이는 Spring Security 설정에서 **`requestMatchers('/admin/**').hasRole("ADMIN")`** 로 설정했기 때문입니다. 따라서 **/admin** 경로로 시작하는 URL은 **ADMIN 권한**을 가진 유저만 접근할 수 있습니다.

![스크린샷 2024-09-05 오후 10.40.10.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/aaffe04d-80cd-45cc-8546-b8ba500cb56b/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-09-05_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.40.10.png)

이는 Spring Security가 사용자의 권한(Role)을 확인하여 접근을 막는 **인가(Authorization)** 과정입니다.

---

**2. 관리자 계정으로 로그인**

DB에서 생성한 계정의 Role을 ADMIN으로 변경해 봅시다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/b559dba2-8b36-4afe-a81e-73d8405a05e1/image.png)

다시 로그인한 후 **home 페이지**에 접속하면, 다음과 같이 **"관리자 페이지로 이동"** 버튼이 보입니다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/b5eae1a0-7312-4bcd-abfb-8b588a26304a/image.png)

**관리자 페이지로 이동** 버튼을 클릭하거나 **/admin** 경로로 접속하면, 이제는 **접근 권한이 부여**되어 관리자로서 페이지에 접속할 수 있습니다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/0a0db42f-91cd-4f30-b95f-408fc9bd8ce7/image.png)

## 실습 1 마무리

이로써 **실습 1**이 완료되었습니다. 이번 실습에서는 Spring Security를 사용하여 간단한 **로그인, 회원가입** 기능을 구현하고, **Role 기반의 인가(Authorization)**로 **페이지 접근 제어**를 다뤘습니다.

해당 실습은 매우 기초적인 개념만 다루기 때문에 다음과 같이 추가적인 개념을 더 공부하고 적용해보시길 바랍니다.

- **CORS & CSRF 설정**:
    - 실무에서는 **CORS**와 **CSRF** 설정도 매우 중요합니다. CORS는 서로 다른 도메인 간의 요청을 처리할 수 있게 해주고, CSRF는 외부에서의 악의적인 요청을 방지하는 보안 기능입니다.
- **JWT 인증**:
    - 이번 실습에서는 **세션 기반 인증**을 사용했지만, **JWT**(JSON Web Token)를 사용하여 더 현대적인 방식으로 인증을 처리할 수 있습니다.
- **필터 커스터마이징**:
    - Spring Security의 필터 체인을 통해, 추가적인 **보안 검사**나 **로깅** 등을 구현할 수 있습니다.

---

# 실습 2: OAuth2를 활용한 카카오 소셜 로그인 구현

이번 실습에서는 **OAuth2**를 이용해 **카카오톡 소셜 로그인**을 구현해보려고 합니다.

OAuth2는 현대 웹 서비스에서 널리 사용되는 인증 프로토콜로, 이번 기회에 간단하게 구현해보면서 그 작동 원리를 이해해봅시다.

## **0. 들어가기 전**

### **OAuth2란 무엇인가요?**

OAuth2는 제3자 애플리케이션이 사용자 대신 안전하게 리소스에 접근할 수 있도록 허용하는 **인증 프로토콜**입니다. 이를 통해 사용자는 비밀번호를 공유하지 않고도 애플리케이션에 접근 권한을 부여할 수 있습니다.

이 프로토콜의 주요 장점은 다음과 같습니다!!!

1. 사용자는 비밀번호를 직접 입력하지 않아도 됩니다.
2. 앱은 사용자의 소셜 계정 정보를 안전하게 받아올 수 있습니다.
3. 사용자는 언제든 앱의 접근 권한을 취소할 수 있습니다.

따라서 소셜 로그인을 구현할 때, OAuth2는 주로 **사용자의 소셜 계정 정보**를 애플리케이션이 안전하게 받아올 수 있게 해줍니다. 카카오톡, 구글, 페이스북 등의 서비스는 이 OAuth2 프로토콜을 통해 **로그인** 및 **권한 관리**를 처리합니다.

 OAuth2 인증 과정의 주요 단계를 간단히 살펴보자면 다음과 같습니다.

![Untitled diagram-2024-10-11-043522.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/cfbd81f6-2fa1-46c2-83a3-568f0248252c/Untitled_diagram-2024-10-11-043522.png)

이번 실습에서는 카카오톡 로그인을 예시로 OAuth2를 어떻게 활용할 수 있는지 살펴보겠습니다.

OAuth2의 더 깊은 내용이 궁금하다면, 다음 자료를 참고해보세요:

- https://spring.io/guides/tutorials/spring-boot-oauth2
- https://www.youtube.com/watch?v=QWjl49py7PM

---

## 1. 프로젝트 설정

실습 1에서 사용한 프로젝트에서 이어서 진행하시면됩니다!!

**로그인 페이지**에 **카카오 소셜 로그인 버튼**을 추가하고, OAuth2 설정을 통해 카카오톡 로그인을 처리하는 부분을 추가해 보겠습니다.

### 1️⃣ 의존성 추가

먼저, Spring Security OAuth2 클라이언트 의존성을 추가해야 합니다. `build.gradle` 파일에 다음 내용을 추가해주세요!!

```groovy
dependencies {

		// ... 기존 의존성 ...

    // Spring Security OAuth2 클라이언트 의존성 추가
    implementation 'org.springframework.boot:spring-boot-starter-oauth2-client'
}
```

이 의존성을 추가함으로써 Spring Boot 애플리케이션에서 OAuth2 클라이언트 기능을 사용할 수 있게 됩니다.

### 2️⃣ 카카오톡 개발자 계정 생성 및 애플리케이션 등록

카카오 로그인을 구현하려면 먼저 카카오 개발자 계정을 만들고 애플리케이션을 등록해야 합니다.

따라서 다음 단계를 따라해 주세요

1. [카카오 디벨로퍼스](https://developers.kakao.com/)에 접속해 **카카오 계정**으로 로그인합니다.
2. 상단의 [내 애플리케이션] 탭에서 [애플리케이션 추가하기]를 클릭합니다.
3. 앱 이름을 입력하고 사업자 정보를 기입합니다. (개인 프로젝트라면 개인으로 설정하세요)

    ![스크린샷 2024-09-05 오후 11.05.13.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/e9b65e2e-944b-4d85-bd4f-bbda41002449/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-09-05_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11.05.13.png)

4. 애플리케이션을 생성한 후, [플랫폼] 설정으로 이동합니다.

    ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/0591b328-4218-460e-9695-368c6f3d9b10/image.png)

5. [Web 플랫폼 등록] 섹션에서 우리 앱의 도메인을 등록합니다.
    - 이번 실습에서는 로컬에서 테스트하기 때문에 `http://localhost:8080`을 입력하세요.

    ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/91a9daa4-0edc-4b00-a1c7-8e65cca0b8e2/image.png)

6. [카카오 로그인] 설정으로 이동해 카카오 로그인을 활성화하고, Redirect URI를 등록합니다.

    ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/c1818d60-1b3c-44f0-bec8-094620a81898/image.png)

    - Redirect URI는 `http://localhost:8080/login/oauth2/code/kakao`로 설정하세요.

        ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/ba7d3819-8378-45cb-b508-a341a9b19f3d/image.png)


    <aside>
    💡

    **Redirect URI란?**

    OAuth2 인증이 성공한 후 사용자가 돌아올 주소입니다. 로컬 테스트 시에는 localhost를 사용하지만, 실제 서비스 배포 시에는 여러분의 서비스 도메인으로 변경해야 합니다!

    </aside>

7. [동의항목] 설정에서 필요한 정보 항목을 선택합니다. 이번 실습에서는 **닉네임을** 필수로 설정해주세요.

    ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/d97f01d0-3983-40a0-b9f7-61083d7474ed/image.png)


<aside>
💡

**주의사항**

이메일 정보를 가져오려면 앱에 대한 추가 설정과 카카오의 심사가 필요할 수 있어요. 실제 서비스 개발 시 이 점을 고려해주세요!

</aside>

---

### 3️⃣ ****`application.yml` **파일에 카카오 OAuth2 정보 추가**

이제 카카오 로그인에 필요한 정보를 우리 앱의 설정 파일에 추가할 차례입니다.

`application.yml` 파일을 열고 다음 내용을 본인 키로 수정해서 추가해주세요:

```yaml
spring:
	# --- 이전 설정 ---
  security:
    oauth2:
      client:
        registration:
          kakao:
            client-authentication-method: client_secret_post
            client-id: { 본인 client-id }
            client-secret: { 본인 client-secret}
            redirect-uri: { 본인 도메인 }/login/oauth2/code/kakao
            authorization-grant-type: authorization_code
            scope: profile_nickname
            client-name: Kakao
        provider:
          kakao:
            authorization-uri: https://kauth.kakao.com/oauth/authorize
            token-uri: https://kauth.kakao.com/oauth/token
            user-info-uri: https://kapi.kakao.com/v2/user/me
            user-name-attribute: id
```

이 설정은 카카오 로그인을 위한 OAuth2 클라이언트를 설정하는 부분입니다. 각 항목을 살펴보겠습니다:

1. `registration` 섹션:
    - `client-id`: 카카오에서 제공한 애플리케이션 ID입니다.
        - 카카오 디벨로퍼스에서 [앱 키] 탭에서 REST API 키를 나타냅니다.

            ![스크린샷 2024-09-05 오후 11.20.29.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/b3ffaf15-e3d6-4d8a-a1a5-c53bbcb53aea/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-09-05_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11.20.29.png)

    - `client-secret`: 카카오에서 제공한 애플리케이션의 비밀 키입니다.
        - 카카오 디벨로퍼스에서 [카카오 로그인][보안] 탭에서 생성할 수 있습니다.

            ![스크린샷 2024-09-05 오후 11.22.35.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/e13c7a1b-29eb-4609-9a86-813976fc72b8/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-09-05_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11.22.35.png)

    - `redirect-uri`: 인증 후 카카오가 사용자를 리다이렉트할 URI입니다. 카카오 개발자 콘솔에서 설정한 URI와 일치해야 합니다.
        - 지금은 로컬에서 테스트하기 때문에 `http://localhost:8080/login/oauth2/code/kakao` 를 입력합니다.
    - `authorization-grant-type`: 사용할 OAuth 2.0 흐름을 지정합니다. `authorization_code`는 웹 애플리케이션의 표준 흐름입니다.
    - `client-authentication-method`: Spring이 카카오에 클라이언트 자격 증명을 어떻게 보낼지 지정합니다. `client_secret_post`는 POST 본문으로 보낸다는 의미입니다.
    - `client-name`: 이 클라이언트 등록의 사람이 읽을 수 있는 이름입니다.
    - `scope`: 앱이 요청하는 권한입니다. 여기서는 사용자의 닉네임을 요청하고 있습니다.
2. `provider` 섹션:
    - `authorization-uri`: 사용자가 카카오로 로그인하기 위해 리다이렉트되는 URL입니다.
    - `token-uri`: 애플리케이션이 인증 코드를 액세스 토큰으로 교환하는 URL입니다.
    - `user-info-uri`: 애플리케이션이 액세스 토큰을 사용하여 사용자 정보를 가져올 수 있는 URL입니다.
    - `user-name-attribute`: 사용자 정보 응답에서 주요 이름으로 사용할 속성을 지정합니다.

이러한 설정을 통해 Spring Security는 카카오와의 OAuth2 흐름을 처리할 수 있습니다. 초기 인증 요청부터 성공적인 인증 후 사용자 정보 가져오기까지 모든 과정을 관리합니다.

---

## **2. 사용자 정보 저장을 위한 CustomOAuth2UserService 구현**

이제 카카오 로그인 후 받은 사용자 정보를 우리 데이터베이스에 저장하는 `CustomOAuth2UserService`를 만들어볼게요.

`src/main/java/umc/study/config/security` 폴더에 `CustomOAuth2UserService` 클래스를 새로 만들고 다음 코드를 작성해주세요:

```groovy
@Service
@RequiredArgsConstructor
public class CustomOAuth2UserService extends DefaultOAuth2UserService {

    private final MemberRepository memberRepository;
    private final PasswordEncoder passwordEncoder;

    @Override
    public OAuth2User loadUser(OAuth2UserRequest userRequest) throws OAuth2AuthenticationException {
        OAuth2User oAuth2User = super.loadUser(userRequest);

        Map<String, Object> attributes = oAuth2User.getAttributes();
        Map<String, Object> properties = (Map<String, Object>) attributes.get("properties");

        String nickname = (String) properties.get("nickname");
        String email = nickname + "@kakao.com"; // 임시 이메일 생성

        // 사용자 정보 저장 또는 업데이트
        Member member = saveOrUpdateUser(email, nickname);

		    // 이메일을 Principal로 사용하기 위해 attributes 수정
        Map<String, Object> modifiedAttributes = new HashMap<>(attributes);
        modifiedAttributes.put("email", email);

        return new DefaultOAuth2User(
            oAuth2User.getAuthorities(),
            modifiedAttributes,
            "email"  // email Principal로 설정
        );
    }

    private Member saveOrUpdateUser(String email, String nickname) {
        Member member = memberRepository.findByEmail(email)
            .orElse(Member.builder()
                .email(email)
                .name(nickname)
                .password(passwordEncoder.encode("OAUTH_USER_" + UUID.randomUUID()))
                .gender(Gender.NONE)  // 기본값 설정
                .address("소셜로그인")  // 기본값 설정
                .specAddress("소셜로그인")  // 기본값 설정
                .role(Role.USER)
                .build());

        return memberRepository.save(member);
    }
}
```

`CustomOAuth2UserService` 클래스는 카카오 로그인 후 받은 사용자 정보를 처리하고 데이터베이스에 저장하는 역할을 합니다. 주요 기능을 다음과 같이 설명할 수 있습니다:

1. **OAuth2User 정보 로드**
    - `super.loadUser(userRequest)`를 통해 카카오에서 제공하는 사용자 정보를 OAuth2User 객체로 받아옵니다.
    - 이 객체의 attributes에는 사용자의 닉네임 등 기본 정보가 포함되어 있습니다.
2. **사용자 정보 추출**
    - 카카오 API에서 제공하는 사용자 정보 중 nickname을 추출합니다.
    - 이메일 정보를 받기 위한 따로 설정하지 않았기 때문에, 닉네임을 이용해 임시 이메일 주소(예: [nickname@kakao.com](mailto:nickname@kakao.com))를 생성합니다.
3. **사용자 정보 저장 및 업데이트**
    - `saveOrUpdateUser` 메소드를 통해 사용자 정보를 데이터베이스에 저장하거나 업데이트합니다.
    - 임시 이메일을 기준으로 기존 사용자를 찾거나 새 사용자를 생성합니다.
    - 카카오에서 제공하지 않는 정보(성별, 주소 등)는 기본값으로 설정합니다.
4. **Spring Security용 OAuth2User 반환**
    - `DefaultOAuth2User` 객체를 생성하여 반환합니다.
    - 사용자의 권한, 속성, 그리고 주요 식별자(email)를 설정합니다.
    - 이를 통해 Spring Security가 인증된 사용자를 올바르게 식별하고 처리할 수 있습니다.

<aside>
💡

**주의사항**

- 실제 서비스에서는 닉네임 대신 고유한 식별자(예: 이메일, 카카오 고유 ID)를 사용하는 것이 더 안정적입니다.
- 소셜 로그인 후 추가 정보 입력 페이지를 통해 필요한 사용자 정보를 수집하는 것이 좋습니다.
</aside>

---

## **3. Spring Security에 OAuth2 설정 추가**

이제 `SecurityConfig`에 OAuth2 관련 설정을 추가해볼게요.

`SecurityConfig` 클래스를 열고 다음과 같이 수정해주세요:

```groovy
@EnableWebSecurity
@Configuration
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
						// ... 기존 설정 ...
            .oauth2Login(oauth2 -> oauth2
                .loginPage("/login")
                .defaultSuccessUrl("/home", true)
                .permitAll()
            );

        return http.build();
    }

    // 기존 빈 설정...
}
```

다음으로, 로그인 페이지에서 카카오 소셜 로그인 버튼을 추가하겠습니다.

`src/main/resources/templates` 폴더에 잇는 기존 `login.html` 파일을 다음과 같이 변경해주세요.

```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <title>Login</title>
</head>
<body>
<!-- 기존 코드 -->

<a th:href="@{/oauth2/authorization/kakao}">카카오로 로그인</a>

</body>
</html>
```

---

## 3. 카카오 로그인 테스트

다시 프로젝트를 빌드하고, [로그인 페이지](http://localhost:8080/login)로 접속합니다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/00250b44-d6cc-4253-b7ea-406cafcf1223/image.png)

카카오로 로그인 버튼을 클릭하게 되면 다음과 같이 개인정보 동의 화면이 나오게 됩니다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/76866624-dd8a-4f8e-9913-f0bd13340216/image.png)

동의한 후, 계속하기 버튼을 클릭하면 로그인이 성공하고 홈 페이지로 리다이렉트됩니다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/25a16ab5-3ffb-4cfa-8995-528d02991716/image.png)

로그를 확인하면 사용자 정보가 데이터베이스에 저장되는 것을 볼 수 있습니다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/547c5911-363d-4d05-a0af-3712f73432ad/image.png)

데이터베이스에서도 새로 생성된 사용자 정보를 확인할 수 있습니다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/4567a2c2-466e-429a-ba5d-ad428329eb04/image.png)

---

## 실습 2 마무리

이번 실습을 통해 OAuth2를 활용한 카카오 소셜 로그인의 구현 과정을 배웠습니다.

이 경험을 바탕으로 다음과 같은 추가 학습과 개선을 고려해볼 수 있습니다.

1. **다양한 소셜 로그인 통합**: 구글, 네이버, 페이스북 등 다른 소셜 로그인을 추가로 구현할 수 있습니다.
- **보안 강화**:
    - JWT를 이용한 토큰 기반 인증 구현
    - HTTPS 적용으로 통신 암호화
    - 로그인 시도 제한 기능 추가
- **사용자 경험 개선**:
    - 소셜 로그인 후 추가 정보 입력 페이지 구현
    - 프로필 관리 기능 추가
- **에러 처리 강화**:
    - 소셜 로그인 실패 시 적절한 에러 메시지 표시
    - 중복 이메일 처리 로직 구현
- **테스트 코드 작성**:
    - OAuth2 로그인 프로세스에 대한 단위 테스트 및 통합 테스트 구현
- **로깅 및 모니터링**:
    - 로그인 시도와 성공/실패에 대한 상세 로깅 추가
    - 모니터링 시스템 연동으로 실시간 사용자 행동 분석

이러한 추가 작업을 통해 더욱 안정적이고 사용자 친화적인 인증 시스템을 구축할 수 있습니다. 소셜 로그인은 현대 웹 서비스의 필수 요소이므로, 이번 실습을 통해 얻은 지식을 실제 프로젝트에 적용해보시기 바랍니다.

## 🎯 핵심 키워드

<aside>
💡 주요 내용들을 정리하고, 여러분만의 생각을 통해 정리해보세요!

- 레퍼런스를 참고하여 정의, 속성, 장단점 등을 적어주셔도 괜찮습니다.
- 조사는 공식 홈페이지 **Best**, 블로그(최신 날짜) **Not Bad**
</aside>

- **Spring Security**

    **1. Spring Security의 주요 개념**

    1. **Authentication (인증)**

    • 사용자의 신원을 확인하는 과정.

    • 예: 사용자 이름과 비밀번호를 확인하여 사용자가 누구인지 파악.

    • 성공하면 Authentication 객체에 사용자 정보와 인증 상태가 저장됨.

    1. **Authorization (권한 부여)**

    • 인증된 사용자가 어떤 리소스에 접근할 수 있는지 결정.

    • 예: 특정 역할(Role)을 가진 사용자만 API 호출 가능.

    1. **Principal**

    • 현재 인증된 사용자를 나타냅니다.

    • SecurityContextHolder에 저장된 Authentication 객체에 포함.

    1. **Filter Chain (필터 체인)**

    • Spring Security는 요청을 처리하기 위해 여러 개의 필터를 체인 형태로 배치.

    • 요청마다 인증과 권한 부여를 처리.

- **인증(Authentication)과 인가(Authorization)**

    **1. 인증 (Authentication)**

    **인증이란 사용자 또는 시스템의 신원을 확인하는 과정**입니다. 즉, “누구인가?“를 확인하는 절차입니다.

    Spring Security는 사용자가 애플리케이션에 로그인할 때 인증 과정을 통해 사용자가 신뢰할 수 있는 사용자임을 확인합니다.

    **인증의 주요 과정:**

    1. **사용자 입력 수집**: 사용자 이름과 비밀번호와 같은 자격 증명(credentials)을 입력받음.
    2. **인증 정보 확인**:

    • 데이터베이스나 LDAP와 같은 저장소에서 자격 증명을 확인.

    • 예: 입력받은 비밀번호가 데이터베이스의 암호화된 비밀번호와 일치하는지 확인.

    1. **인증 성공 시**:

    • Spring Security는 Authentication 객체를 생성하여 인증된 사용자 정보를 저장.

    • 해당 객체는 SecurityContext에 저장되어 애플리케이션 전반에서 사용자 정보를 참조할 수 있게 함.

    1. **인증 실패 시**:

    • Spring Security는 인증 실패 이벤트를 처리하고, 사용자에게 적절한 메시지를 반환.

    **2. 인가 (Authorization)**

    **인가란 인증된 사용자가 어떤 리소스에 접근할 수 있는지 권한을 부여하는 과정**입니다. 즉, “이 일을 할 수 있는 권한이 있는가?“를 확인합니다.

    Spring Security는 인증된 사용자가 특정 작업을 수행하거나 리소스에 접근하려고 할 때 권한을 확인합니다.

    **인가의 주요 과정:**

    1. **인증 후 권한 확인**:

    • 사용자의 Role 또는 Authority를 확인.

    • 예: 사용자가 ROLE_ADMIN 또는 ROLE_USER 권한을 가지고 있는지 확인.

    1. **리소스 보호**:

    • URL, 메서드, 데이터에 대한 접근 권한 설정.

    • Spring Security 설정을 통해 특정 경로 또는 메서드에 대한 접근 권한을 제한할 수 있음.

    1. **접근 허용**:

    • 권한이 있는 경우, 요청한 리소스를 반환하거나 작업을 수행.

    1. **접근 거부**:

    • 권한이 없는 경우, HTTP 403 Forbidden 응답 반환.


## 📢 학습 후기

<aside>
💡 이번 주차 워크북을 해결해보면서 어땠는지 회고해봅시다.

- Spring Security와 OAuth2에 대해 완전히 이해했나요?
- 혹시 이해가 안 되는 부분이 있었나요?
- 이번 실습에서 어려웠던 부분은 무엇이었나요?
</aside>

## ⚠️ 스터디 진행 방법

1. 스터디를 진행하기 전, 워크북 내용들을 모두 채우고 스터디에서는 서로 모르는 내용들을 공유해주세요.
2. 미션은 워크북 내용들을 모두 완료하고 나서 스터디 전/후로 진행해보세요.
3. 다음주 스터디를 진행하기 전, 지난주 미션을 서로 공유해서 상호 피드백을 진행하시면 됩니다.

## 🔥 미션

<aside>
📍 **주의 사항**

결과물만 올리면 안되고, 중간 과정 또한 기록을 남겨주셔야 합니다.
(DB 연결, 테이블 생성 등)

**결과물과 중간 과정 모두 기록하여 제출**하라는 뜻입니다.

</aside>

### 필수 미션

1. **실습 1: Spring Security를 활용한 로그인 및 회원가입 구현**
    - 회원가입, 로그인, 로그아웃 기능을 구현하고 **DB에 저장**되는 과정을 캡처하고 설명하세요.
2. **실습 2: OAuth2를 이용한 카카오톡 소셜 로그인 구현**
    - 카카오 OAuth2 소셜 로그인을 적용하고, 회원 정보를 DB에 저장하는 과정을 기록하세요.

- 아래는 실습 참고 코드입니다.

    [GitHub - chock-cho/UMC-7th-spring-workbook at feature-week10-workbook](https://github.com/chock-cho/UMC-7th-spring-workbook/tree/feature-week10-workbook)


### 선택 미션

- **구글 또는 네이버 소셜 로그인 추가 구현**
    - 카카오와 동일한 방식으로 구글 또는 네이버 소셜 로그인을 추가로 구현해 보세요.
    - 결과물과 중간 과정을 기록하여 제출하세요.

## 💪 미션 기록

<aside>
🍀 미션 기록의 경우, 아래 미션 기록 토글 속에 작성하시거나, 페이지를 새로 생성하여 해당 페이지에 기록하여도 좋습니다!

하지만, 결과물만 올리는 것이 아닌, **중간 과정 모두 기록하셔야 한다는 점!** 잊지 말아주세요.

</aside>

- **미션 기록**

> **GitHub 저장소 주소**
>
>
> https://github.com/…
>

## ⚡ 트러블 슈팅

<aside>
💡 실습하면서 생긴 문제들에 대해서, **이슈 - 문제 - 해결** 순서로 작성해주세요.

스스로 해결하기 어렵다면? 스터디원들에게 도움을 요청하거나 **너디너리의 지식IN 채널**에 질문해보세요!

</aside>

- ⚡이슈 작성 예시 (이슈가 생기면 아래를 복사해서 No. 1, No. 2, No. 3, … 으로 작성해서 트러블 슈팅을 꼭 해보세요!)

    **`이슈`**

    👉 앱 실행 중에 노래 다음 버튼을 누르니까 앱이 종료되었다.

    **`문제`**

    👉 노래클래스의 데이터리스트의 Size를 넘어서 NullPointException이 발생하여 앱이 종료된 것이었다.

    **`해결`**

    👉  노래 다음 버튼을 눌렀을 때 데이터리스트의 Size를 검사해 Size보다 넘어가려고 하면 다음으로 넘어가는 메서드를 실행시키지 않고, 첫 노래로 돌아가게끔 해결

    **`참고 레퍼런스`**

    - 링크
- ⚡이슈 No. 1

    **`이슈`**

    👉 [트러블이 생긴 상태 작성]

    **`문제`**

    👉 [어떤 이유로 해당 이슈가 일어났는지 작성]

    **`해결`**

    👉  [해결 방법 작성]

    **`참고 레퍼런스`**

    - [문제 해결 시 참고한 링크]

Copyright © 2024 김준석(벡스) All rights reserved.